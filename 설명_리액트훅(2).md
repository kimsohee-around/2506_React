## 리액트 훅(Hook)

**훅(Hook)** 은 React 함수형 컴포넌트 안에서 React의 상태(state), 생명주기(lifecycle), context API 등의 기능을 사용할 수 있도록 해주는 함수입니다.

대표적인 훅: useState, useEffect, useRef, useContext, useReducer, useCallback, useMemo, 등

### useState 훅

- 개념:
  컴포넌트 내에서 상태(state)를 생성하고 관리할 수 있게 해주는 훅

- 호출 시 배열을 반환: [현재 상태 값, 상태를 변경하는 함수]

사용 예시:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // 초기값은 0

  return (
    <div>
      <p>현재 카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

- 특징:
  - 상태가 변경되면 컴포넌트가 자동으로 리렌더링
  - useState는 비동기적으로 동작함

### useRef 훅

- 개념:
  DOM 요소에 직접 접근하거나, 렌더링과 무관한 값을 저장할 때 사용하는 훅

- 변경해도 컴포넌트를 리렌더링하지 않음

- 사용 예시 1: DOM에 직접 접근

```jsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus(); // DOM 요소에 직접 접근
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>포커스 이동</button>
    </>
  );
}
```

- 사용 예시 2: 값 저장 용도 (예: 이전 값 기억)

```jsx
import { useEffect, useRef, useState } from "react";

function PreviousValue() {
  const [count, setCount] = useState(0);
  const prevCount = useRef(0);

  useEffect(() => {
    prevCount.current = count;
  }, [count]);

  return (
    <div>
      <p>현재 값: {count}</p>
      <p>이전 값: {prevCount.current}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

- 특징:
  .current 속성을 통해 값에 접근

- 값이 바뀌어도 컴포넌트는 리렌더링되지 않음

- 주로 setTimeout, setInterval, 외부 라이브러리 접근, 이전 값 저장 등에 사용

### useEffect 훅

useEffect는 리액트의 함수형 컴포넌트에서 부수 효과(side effect)를 처리하기 위한 훅입니다.

#### ✅ 주요 용도

- 컴포넌트가 렌더링된 직후 어떤 작업을 실행할 때
- 데이터 요청, 구독 설정, 이벤트 리스너 등록 등 외부와의 상호작용
- 타이머, 애니메이션, 로컬 스토리지 제어
- 정리(clean-up) 작업 처리

- 🔧 기본 문법

```jsx
useEffect(() => {
  // 실행할 코드 (side effect)
  return () => {
    // cleanup 함수 (옵션)
  };
}, [의존성 배열]);
```

- 예제 1: 컴포넌트가 처음 렌더링될 때만 실행

```jsx
useEffect(() => {
  console.log("컴포넌트가 처음 렌더링됨");
}, []);
// [] 빈 배열이므로 마운트 시 딱 1번만 실행
```

- 예제 2: 상태가 변경될 때마다 실행

```jsx
const [count, setCount] = useState(0);

useEffect(() => {
  console.log(`count 값이 ${count}로 변경됨`);
}, [count]);
// count가 바뀔 때마다 실행됨
```

- 예제 3: 언마운트 시 정리 작업 수행

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log("타이머 실행중...");
  }, 1000);

  return () => {
    clearInterval(timer); // 언마운트 시 타이머 정리
    console.log("타이머 정리됨");
  };
}, []);
// 정리(cleanup) 함수는 컴포넌트가 언마운트될 때 또는 의존성이 바뀌기 직전에 실행
```

#### 📌 동작 순서 정리

- 컴포넌트 렌더링 → useEffect 실행

- 다음 렌더링 전에 (또는 언마운트 시) 이전 return의 정리(clean-up) 함수 실행

- 의존성 배열에 변화가 있을 경우에만 다시 실행

#### 📋 의존성 배열 설명

의존성 배열 실행 시점
없음 (useEffect(() => {...})) 매 렌더링마다 실행
빈 배열 ([]) 처음 렌더링 시 한 번만
특정 값 ([value]) 그 값이 바뀔 때만 실행

🚨 주의사항

- 무한 루프에 주의: 상태 변경 → 리렌더링 → useEffect → 다시 상태 변경 ...
- 비동기 함수는 useEffect 내부에서 사용할 때 직접 async로 선언하면 안 됩니다.
  (useEffect의 "콜백 함수 자체를 async로 정의하면 안 됩니다.")

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch(...);
    const data = await res.json();
  }
  fetchData();
}, []);
// 비동기 함수는 별도 함수 정의 
```

#### 🔚 주요 용도

- API 호출, 타이머 설정 등
